# Binary to 3D Coordinates Mapper

This script converts a binary file into a three-dimensional representation by mapping each bit to coordinates in a 3D space.

## Description

The `binary_to_3d.py` script reads a binary file and processes each bit, mapping it to a unique position in a three-dimensional space. The output format is:

```
(x, y, z)	bit_value
```

Where:
- `(x, y, z)` represents the coordinates in 3D space
- `bit_value` is either 0 or 1

The script supports multiple mapping modes to distribute bits in 3D space, including sequential filling and various random distributions. If the binary file doesn't contain enough bits to fill the entire 3D space, the script can fill the remaining positions with a default bit value.

## Usage

```bash
python binary_to_3d.py input_file [-o OUTPUT] [-d X Y Z] [-m MODE] [--no-fill] [--default-bit {0,1}] [--seed SEED]
```

### Arguments

- `input_file`: Path to the input binary file
- `-o, --output`: (Optional) Path to the output file. If not provided, output is printed to stdout
- `-d, --dimensions`: (Optional) Dimensions of the 3D space as "x y z" (default: 16 16 16)
- `-m, --mode`: (Optional) Mapping mode (default: sequential)
  - `sequential`: Map bits sequentially through the 3D space
  - `random_positions`: Randomly shuffle the 3D positions but maintain one-to-one mapping
  - `random_assignment`: Randomly assign each bit to a position (may have multiple bits per position)
- `--no-fill`: (Optional) Do not fill empty positions with default bit value
- `--default-bit`: (Optional) Default bit value for empty positions (0 or 1, default: 0)
- `--seed`: (Optional) Random seed for reproducibility of random mappings

### Examples

Basic usage (sequential mapping):
```bash
python binary_to_3d.py sample.bin
```

Save output to a file:
```bash
python binary_to_3d.py sample.bin -o output.txt
```

Specify custom dimensions and ensure all positions are filled:
```bash
python binary_to_3d.py sample.bin -d 8 8 8
```

Use random positions mapping with no filling of empty positions:
```bash
python binary_to_3d.py sample.bin -m random_positions --no-fill
```

Fill empty positions with 1 instead of 0:
```bash
python binary_to_3d.py sample.bin -d 8 8 8 --default-bit 1
```

Use completely random assignment:
```bash
python binary_to_3d.py sample.bin -m random_assignment
```

Use a random seed for reproducible results:
```bash
python binary_to_3d.py sample.bin -m random_positions --seed 42
```

## Sample File Generator

The repository includes a sample file generator (`generate_sample.py`) to create test binary files:

```bash
python generate_sample.py [-o OUTPUT] [-s SIZE] [-t TYPE] [-p PROBABILITY] [--seed SEED]
```

### Arguments

- `-o, --output`: (Optional) Path to the output binary file (default: sample.bin)
- `-s, --size`: (Optional) Size of the file in bytes (default: 64)
- `-t, --type`: (Optional) Type of data to generate:
  - `random`: Pseudo-random bits using Python's random module (default)
  - `truly_random`: High-quality random bits using os.urandom
  - `custom`: Bits with custom probability distribution
  - `checkerboard`: Alternating 0s and 1s
  - `gradient`: Increasing values from 0 to 255
  - `zeros`: All zeros
  - `ones`: All ones
  - `random_patterns`: Mixed patterns with sections of random, gradients, and alternating bits
- `-p, --probability`: (Optional) Probability of a bit being 1 for custom distribution (default: 0.5)
- `--seed`: (Optional) Random seed for reproducibility

### Examples

Generate random sample:
```bash
python generate_sample.py
```

Generate truly random data:
```bash
python generate_sample.py -t truly_random -s 128
```

Generate data with custom bit probability:
```bash
python generate_sample.py -t custom -p 0.7
```

Generate checkerboard pattern:
```bash
python generate_sample.py -t checkerboard -s 128
```

Generate with a specific random seed:
```bash
python generate_sample.py --seed 42
```

## 3D Visualization

The repository includes a visualization script (`visualize_3d.py`) to help visualize the 3D data using matplotlib:

```bash
python visualize_3d.py input_file [--hide-zeros] [--color-map COLOR_MAP]
```

### Requirements

The visualization script requires matplotlib and numpy. Install them using:

```bash
pip install matplotlib numpy
```

### Arguments

- `input_file`: Path to the coordinate file generated by binary_to_3d.py
- `--hide-zeros`: (Optional) Hide 0-bits in the visualization (by default, both 0-bits and 1-bits are shown)
- `--color-map`: (Optional) Matplotlib colormap to use for visualization (default: viridis)

### Examples

Visualize all bits (0s and 1s):
```bash
python visualize_3d.py coordinates.txt
```

Show only 1-bits (hide 0-bits):
```bash
python visualize_3d.py coordinates.txt --hide-zeros
```

Use a different color map:
```bash
python visualize_3d.py coordinates.txt --color-map hot
```

### Visualization Features

- 0-bits are shown in blue
- 1-bits are shown in red
- Equal aspect ratio for all axes to ensure proper 3D representation
- Alpha transparency to see overlapping points
- Z-axis displays integer values from 0 to 8

## Complete Example Workflow

1. Generate a truly random sample file:
```bash
python generate_sample.py -t truly_random -o test.bin -s 32
```

2. Convert the binary file to 3D coordinates with random positions, filling all 8×8×8=512 positions:
```bash
python binary_to_3d.py test.bin -o coordinates.txt -d 8 8 8 -m random_positions
```

3. View the results:
```bash
cat coordinates.txt | wc -l  # Should show 512 lines
```

4. Visualize the data in 3D:
```bash
python visualize_3d.py coordinates.txt
```

## Notes

- The script will automatically fill any empty positions with a default bit value (0 by default) to ensure all coordinates have data.
- If you don't want to fill empty positions, use the `--no-fill` option.
- By default, the script uses a 16×16×16 grid, which can store up to 4,096 bits (512 bytes).
- For larger files, consider increasing the dimensions with the `-d` option.
- Random mapping modes may produce different results each time unless a seed is specified.
- The Z-axis in visualization is fixed to display up to 8 levels (0-8) with integer tick marks.